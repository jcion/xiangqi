<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xiangqi (Chinese Chess)</title>
    <style>
        :root {
            --board-color: #e8c28d;
            --river-color: #f5f5f5;
            --line-color: #000;
            --palace-color: #ab6b51;
            --red-piece: #d03438;
            --black-piece: #252525;
            --board-width: 90vmin;
            --board-height: 100vmin;
            --grid-size: calc(var(--board-width) / 9);
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            height: 100vh;
            margin: 0;
            padding: 0;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: var(--board-width);
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 10px;
        }

        h1 {
            margin: 20px 0 10px 0;
            color: #333;
        }

        .game-info {
            margin-bottom: 10px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .board-container {
            position: relative;
            width: var(--board-width);
            height: var(--board-height);
            background-color: var(--board-color);
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .board {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Grid lines */
        .horizontal-line, .vertical-line {
            position: absolute;
            background-color: var(--line-color);
        }

        .horizontal-line {
            height: 2px;
            width: calc(100% - var(--grid-size) / 4);
            left: calc(var(--grid-size) / 8);
        }

        .vertical-line {
            width: 2px;
            height: calc(100% - var(--grid-size) / 4);
            top: calc(var(--grid-size) / 8);
        }

        /* River */
        .river {
            position: absolute;
            background-color: var(--river-color);
            width: 100%;
            height: calc(var(--grid-size) / 2);
            top: calc(var(--board-height) / 2 - var(--grid-size) / 4);
        }

        .river-text {
            position: absolute;
            font-size: calc(var(--grid-size) / 3);
            color: var(--line-color);
            font-weight: bold;
            top: 50%;
            transform: translateY(-50%);
        }

        .river-text.left {
            left: calc(var(--grid-size) * 2);
        }

        .river-text.right {
            right: calc(var(--grid-size) * 2);
        }

        /* Palaces */
        .palace {
            position: absolute;
            width: calc(var(--grid-size) * 2);
            height: calc(var(--grid-size) * 2);
        }

        .palace-diagonal {
            position: absolute;
            width: calc(var(--grid-size) * 2);
            height: 2px;
            background-color: var(--line-color);
            top: 50%;
            left: 0;
            transform-origin: center;
        }

        .palace-diagonal.left-to-right {
            transform: rotate(45deg);
        }

        .palace-diagonal.right-to-left {
            transform: rotate(-45deg);
        }

        .palace.red {
            left: calc(var(--grid-size) * 3.5);
            top: calc(var(--board-height) - var(--grid-size) * 2);
        }

        .palace.black {
            left: calc(var(--grid-size) * 3.5);
            top: 0;
        }

        /* Piece styling */
        .piece {
            position: absolute;
            width: calc(var(--grid-size) * 0.85);
            height: calc(var(--grid-size) * 0.85);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            transform: translate(-50%, -50%);
            transition: all 0.2s ease;
            user-select: none;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
            font-family: 'Arial', sans-serif;
        }

        .piece.red {
            background-color: #f8e0e0;
            color: var(--red-piece);
            border: 2px solid var(--red-piece);
        }

        .piece.black {
            background-color: #e0e0e0;
            color: var(--black-piece);
            border: 2px solid var(--black-piece);
        }

        .piece.selected {
            box-shadow: 0 0 0 4px rgba(255, 255, 0, 0.6);
        }

        .piece.valid-move {
            box-shadow: 0 0 0 4px rgba(0, 255, 0, 0.4);
        }

        .piece-text {
            font-size: calc(var(--grid-size) * 0.4);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Universal piece symbols */
        .piece[data-type="general"] .piece-text::before {
            content: '‚ôö';
            font-size: calc(var(--grid-size) * 0.5);
        }
        
        .piece[data-type="advisor"] .piece-text::before {
            content: '‚ôù';
            font-size: calc(var(--grid-size) * 0.5);
        }
        
        .piece[data-type="elephant"] .piece-text::before {
            content: 'üêò';
            font-size: calc(var(--grid-size) * 0.4);
        }
        
        .piece[data-type="horse"] .piece-text::before {
            content: '‚ôû';
            font-size: calc(var(--grid-size) * 0.5);
        }
        
        .piece[data-type="chariot"] .piece-text::before {
            content: '‚ôú';
            font-size: calc(var(--grid-size) * 0.5);
        }
        
        .piece[data-type="cannon"] .piece-text::before {
            content: '‚äï';
            font-size: calc(var(--grid-size) * 0.5);
        }
        
        .piece[data-type="soldier"] .piece-text::before {
            content: '‚ôü';
            font-size: calc(var(--grid-size) * 0.5);
        }

        /* Highlight spots for possible moves */
        .move-highlight {
            position: absolute;
            width: calc(var(--grid-size) * 0.3);
            height: calc(var(--grid-size) * 0.3);
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.4);
            transform: translate(-50%, -50%);
            z-index: 5;
            cursor: pointer;
        }

        /* Point marks at soldier starting positions */
        .point-mark {
            position: absolute;
            width: 10px;
            height: 10px;
            transform: translate(-50%, -50%);
        }

        .point-mark::before, .point-mark::after {
            content: '';
            position: absolute;
            background-color: var(--line-color);
        }

        .point-mark::before {
            width: 100%;
            height: 2px;
            top: 4px;
            left: 0;
        }

        .point-mark::after {
            width: 2px;
            height: 100%;
            top: 0;
            left: 4px;
        }

        /* Game controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }

        .controls button {
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .controls button:hover {
            background-color: #3a7bc8;
        }
        
        .controls button.active {
            background-color: #45a049;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            :root {
                --board-width: 95vw;
                --board-height: 105vw;
            }

            .piece-text {
                font-size: calc(var(--grid-size) * 0.4);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>Xiangqi (Chinese Chess)</h1>
        <div style="font-size: 0.9rem; margin-bottom: 15px; color: #666; max-width: 600px; text-align: center;">
            <p><strong>Pieces:</strong> 
            ‚ôö General (moves one space orthogonally, stays in palace) | 
            ‚ôù Advisor (moves one space diagonally, stays in palace) | 
            üêò Elephant (moves exactly two spaces diagonally, doesn't cross river) | 
            ‚ôû Horse (moves one orthogonally then one diagonally) | 
            ‚ôú Chariot (moves any distance orthogonally) | 
            ‚äï Cannon (moves like chariot, captures by jumping) | 
            ‚ôü Soldier (moves forward, also sideways after crossing river)</p>
        </div>
        </div>
        <div class="game-info" id="game-info">Red's Turn</div>
        <div class="board-container">
            <div class="board" id="board">
                <!-- River -->
                <div class="river">
                    <div class="river-text left">Ê•öÊ≤≥</div>
                    <div class="river-text right">Êº¢Áïå</div>
                </div>
                <!-- Grid will be generated by JavaScript -->
            </div>
        </div>
        <div class="controls">
            <button id="new-game">New Game</button>
            <button id="undo-move">Undo Move</button>
            <button id="ai-toggle">AI Opponent: OFF</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game constants
            const BOARD_WIDTH = 9;
            const BOARD_HEIGHT = 10;
            const RED = 'red';
            const BLACK = 'black';

            // Game state
            let selectedPiece = null;
            let currentPlayer = RED;
            let gameOver = false;
            let moveHistory = [];
            let aiEnabled = false;
            let aiThinking = false;
            
            // Piece labels for display in game info
            const pieceLabels = {
                [RED]: {
                    'general': 'General',
                    'advisor': 'Advisor',
                    'elephant': 'Elephant',
                    'horse': 'Horse',
                    'chariot': 'Chariot',
                    'cannon': 'Cannon',
                    'soldier': 'Soldier'
                },
                [BLACK]: {
                    'general': 'General',
                    'advisor': 'Advisor',
                    'elephant': 'Elephant',
                    'horse': 'Horse',
                    'chariot': 'Chariot',
                    'cannon': 'Cannon',
                    'soldier': 'Soldier'
                }
            };

            // DOM elements
            const boardElement = document.getElementById('board');
            const gameInfoElement = document.getElementById('game-info');
            const newGameButton = document.getElementById('new-game');
            const undoMoveButton = document.getElementById('undo-move');
            const aiToggleButton = document.getElementById('ai-toggle');

            // Initialize game
            function initGame() {
                // Clear the board
                boardElement.innerHTML = '';
                
                // Add river
                const river = document.createElement('div');
                river.className = 'river';
                
                const leftText = document.createElement('div');
                leftText.className = 'river-text left';
                leftText.textContent = 'Ê•öÊ≤≥';
                
                const rightText = document.createElement('div');
                rightText.className = 'river-text right';
                rightText.textContent = 'Êº¢Áïå';
                
                river.appendChild(leftText);
                river.appendChild(rightText);
                boardElement.appendChild(river);
                
                // Add grid lines
                for (let i = 0; i < BOARD_HEIGHT; i++) {
                    const line = document.createElement('div');
                    line.className = 'horizontal-line';
                    line.style.top = `${(i * 10)}%`;
                    boardElement.appendChild(line);
                }
                
                for (let i = 0; i < BOARD_WIDTH; i++) {
                    const line = document.createElement('div');
                    line.className = 'vertical-line';
                    line.style.left = `${(i * (100 / BOARD_WIDTH))}%`;
                    boardElement.appendChild(line);
                }
                
                // Add palaces
                const redPalace = document.createElement('div');
                redPalace.className = 'palace red';
                
                const redDiagonal1 = document.createElement('div');
                redDiagonal1.className = 'palace-diagonal left-to-right';
                
                const redDiagonal2 = document.createElement('div');
                redDiagonal2.className = 'palace-diagonal right-to-left';
                
                redPalace.appendChild(redDiagonal1);
                redPalace.appendChild(redDiagonal2);
                boardElement.appendChild(redPalace);
                
                const blackPalace = document.createElement('div');
                blackPalace.className = 'palace black';
                
                const blackDiagonal1 = document.createElement('div');
                blackDiagonal1.className = 'palace-diagonal left-to-right';
                
                const blackDiagonal2 = document.createElement('div');
                blackDiagonal2.className = 'palace-diagonal right-to-left';
                
                blackPalace.appendChild(blackDiagonal1);
                blackPalace.appendChild(blackDiagonal2);
                boardElement.appendChild(blackPalace);
                
                // Add soldier and cannon position marks
                const soldierPositions = [
                    {x: 0, y: 3}, {x: 2, y: 3}, {x: 4, y: 3}, {x: 6, y: 3}, {x: 8, y: 3},
                    {x: 0, y: 6}, {x: 2, y: 6}, {x: 4, y: 6}, {x: 6, y: 6}, {x: 8, y: 6}
                ];
                
                const cannonPositions = [
                    {x: 1, y: 2}, {x: 7, y: 2},
                    {x: 1, y: 7}, {x: 7, y: 7}
                ];
                
                [...soldierPositions, ...cannonPositions].forEach(pos => {
                    const mark = document.createElement('div');
                    mark.className = 'point-mark';
                    mark.style.left = `${pos.x * (100 / BOARD_WIDTH) + (100 / BOARD_WIDTH / 2)}%`;
                    mark.style.top = `${pos.y * 10 + 5}%`;
                    boardElement.appendChild(mark);
                });
                
                // Initialize pieces
                setupInitialPieces();
                
                // Reset game state
                selectedPiece = null;
                currentPlayer = RED;
                gameOver = false;
                moveHistory = [];
                updateGameInfo();
                
                // Reset AI toggle button to OFF state
                aiEnabled = false;
                aiToggleButton.textContent = 'AI Opponent: OFF';
                aiToggleButton.classList.remove('active');
            }

            // Setup initial piece positions
            function setupInitialPieces() {
                // Add pieces
                const initialPieces = [
                    // Red pieces
                    {type: 'chariot', color: RED, x: 0, y: 9},
                    {type: 'horse', color: RED, x: 1, y: 9},
                    {type: 'elephant', color: RED, x: 2, y: 9},
                    {type: 'advisor', color: RED, x: 3, y: 9},
                    {type: 'general', color: RED, x: 4, y: 9},
                    {type: 'advisor', color: RED, x: 5, y: 9},
                    {type: 'elephant', color: RED, x: 6, y: 9},
                    {type: 'horse', color: RED, x: 7, y: 9},
                    {type: 'chariot', color: RED, x: 8, y: 9},
                    {type: 'cannon', color: RED, x: 1, y: 7},
                    {type: 'cannon', color: RED, x: 7, y: 7},
                    {type: 'soldier', color: RED, x: 0, y: 6},
                    {type: 'soldier', color: RED, x: 2, y: 6},
                    {type: 'soldier', color: RED, x: 4, y: 6},
                    {type: 'soldier', color: RED, x: 6, y: 6},
                    {type: 'soldier', color: RED, x: 8, y: 6},
                    
                    // Black pieces
                    {type: 'chariot', color: BLACK, x: 0, y: 0},
                    {type: 'horse', color: BLACK, x: 1, y: 0},
                    {type: 'elephant', color: BLACK, x: 2, y: 0},
                    {type: 'advisor', color: BLACK, x: 3, y: 0},
                    {type: 'general', color: BLACK, x: 4, y: 0},
                    {type: 'advisor', color: BLACK, x: 5, y: 0},
                    {type: 'elephant', color: BLACK, x: 6, y: 0},
                    {type: 'horse', color: BLACK, x: 7, y: 0},
                    {type: 'chariot', color: BLACK, x: 8, y: 0},
                    {type: 'cannon', color: BLACK, x: 1, y: 2},
                    {type: 'cannon', color: BLACK, x: 7, y: 2},
                    {type: 'soldier', color: BLACK, x: 0, y: 3},
                    {type: 'soldier', color: BLACK, x: 2, y: 3},
                    {type: 'soldier', color: BLACK, x: 4, y: 3},
                    {type: 'soldier', color: BLACK, x: 6, y: 3},
                    {type: 'soldier', color: BLACK, x: 8, y: 3}
                ];
                
                initialPieces.forEach(piece => {
                    createPieceElement(piece);
                });
            }

            // Create a piece DOM element
            function createPieceElement(piece) {
                const pieceElement = document.createElement('div');
                pieceElement.className = `piece ${piece.color}`;
                pieceElement.dataset.type = piece.type;
                pieceElement.dataset.color = piece.color;
                pieceElement.dataset.x = piece.x;
                pieceElement.dataset.y = piece.y;
                
                const pieceTextElement = document.createElement('div');
                pieceTextElement.className = 'piece-text';
                
                pieceElement.appendChild(pieceTextElement);
                
                // Position the piece
                updatePiecePosition(pieceElement);
                
                // Add event listener
                pieceElement.addEventListener('click', handlePieceClick);
                
                boardElement.appendChild(pieceElement);
                return pieceElement;
            }

            // Position a piece on the board
            function updatePiecePosition(pieceElement) {
                const x = parseInt(pieceElement.dataset.x);
                const y = parseInt(pieceElement.dataset.y);
                
                pieceElement.style.left = `${x * (100 / BOARD_WIDTH) + (100 / BOARD_WIDTH / 2)}%`;
                pieceElement.style.top = `${y * 10 + 5}%`;
            }

            // Handle piece click event
            function handlePieceClick(event) {
                if (gameOver) return;
                
                const pieceElement = event.currentTarget;
                const pieceColor = pieceElement.dataset.color;
                const x = parseInt(pieceElement.dataset.x);
                const y = parseInt(pieceElement.dataset.y);
                
                // If clicking on a piece of current player's color
                if (pieceColor === currentPlayer) {
                    // Deselect if same piece is clicked
                    if (selectedPiece === pieceElement) {
                        deselectPiece();
                    } else {
                        // Select the piece
                        selectPiece(pieceElement);
                    }
                } 
                // If a piece is already selected and clicking on another position
                else if (selectedPiece && isPossibleMove(
                    parseInt(selectedPiece.dataset.x),
                    parseInt(selectedPiece.dataset.y),
                    x, y
                )) {
                    // Move the selected piece to the new position
                    movePiece(selectedPiece, x, y);
                }
            }

            // Select a piece
            function selectPiece(pieceElement) {
                // Deselect previously selected piece
                if (selectedPiece) {
                    deselectPiece();
                }
                
                // Mark new piece as selected
                selectedPiece = pieceElement;
                pieceElement.classList.add('selected');
                
                // Show possible moves
                const x = parseInt(pieceElement.dataset.x);
                const y = parseInt(pieceElement.dataset.y);
                const pieceType = pieceElement.dataset.type;
                
                showPossibleMoves(x, y, pieceType);
            }

            // Deselect the current piece
            function deselectPiece() {
                if (selectedPiece) {
                    selectedPiece.classList.remove('selected');
                    
                    // Remove all move highlights
                    document.querySelectorAll('.move-highlight').forEach(highlight => {
                        highlight.remove();
                    });
                    
                    // Remove valid-move class from pieces
                    document.querySelectorAll('.valid-move').forEach(piece => {
                        piece.classList.remove('valid-move');
                    });
                    
                    selectedPiece = null;
                }
            }

            // Show possible moves for a piece
            function showPossibleMoves(x, y, pieceType) {
                const possibleMoves = [];
                
                // Get all possible moves based on piece type
                switch (pieceType) {
                    case 'general':
                        possibleMoves.push(...getGeneralMoves(x, y));
                        break;
                    case 'advisor':
                        possibleMoves.push(...getAdvisorMoves(x, y));
                        break;
                    case 'elephant':
                        possibleMoves.push(...getElephantMoves(x, y));
                        break;
                    case 'horse':
                        possibleMoves.push(...getHorseMoves(x, y));
                        break;
                    case 'chariot':
                        possibleMoves.push(...getChariotMoves(x, y));
                        break;
                    case 'cannon':
                        possibleMoves.push(...getCannonMoves(x, y));
                        break;
                    case 'soldier':
                        possibleMoves.push(...getSoldierMoves(x, y));
                        break;
                }
                
                // Display the possible moves
                possibleMoves.forEach(move => {
                    // Check if there's an opponent's piece at this position
                    const targetPiece = getPieceAtPosition(move.x, move.y);
                    
                    if (targetPiece) {
                        targetPiece.classList.add('valid-move');
                    } else {
                        // Create a move highlight element
                        const highlight = document.createElement('div');
                        highlight.className = 'move-highlight';
                        highlight.style.left = `${move.x * (100 / BOARD_WIDTH) + (100 / BOARD_WIDTH / 2)}%`;
                        highlight.style.top = `${move.y * 10 + 5}%`;
                        
                        // Add click event to move the piece
                        highlight.addEventListener('click', () => {
                            if (selectedPiece) {
                                movePiece(selectedPiece, move.x, move.y);
                            }
                        });
                        
                        boardElement.appendChild(highlight);
                    }
                });
            }

            // Get possible moves for General/King
            function getGeneralMoves(x, y) {
                const color = currentPlayer;
                const moves = [];
                const directions = [
                    {dx: 0, dy: 1}, {dx: 1, dy: 0}, 
                    {dx: 0, dy: -1}, {dx: -1, dy: 0}
                ];
                
                directions.forEach(dir => {
                    const newX = x + dir.dx;
                    const newY = y + dir.dy;
                    
                    // Check if the move is within the palace
                    if (isWithinPalace(newX, newY, color) && 
                        (getPieceAtPosition(newX, newY)?.dataset.color !== color || !getPieceAtPosition(newX, newY))) {
                        moves.push({x: newX, y: newY});
                    }
                });
                
                // Check for flying general move
                if (canFlyGeneral(x, y)) {
                    const enemyGeneral = findEnemyGeneral();
                    if (enemyGeneral) {
                        moves.push({
                            x: parseInt(enemyGeneral.dataset.x),
                            y: parseInt(enemyGeneral.dataset.y)
                        });
                    }
                }
                
                return moves;
            }

            // Check if a position is within the palace
            function isWithinPalace(x, y, color) {
                // Red palace
                if (color === RED) {
                    return x >= 3 && x <= 5 && y >= 7 && y <= 9;
                }
                // Black palace
                else {
                    return x >= 3 && x <= 5 && y >= 0 && y <= 2;
                }
            }

            // Check if the general can fly (move along a file to capture enemy general)
            function canFlyGeneral(x, y) {
                const enemyGeneral = findEnemyGeneral();
                if (!enemyGeneral) return false;
                
                const enemyX = parseInt(enemyGeneral.dataset.x);
                const enemyY = parseInt(enemyGeneral.dataset.y);
                
                // Generals must be on the same file
                if (x !== enemyX) return false;
                
                // Check if there are any pieces between them
                const minY = Math.min(y, enemyY);
                const maxY = Math.max(y, enemyY);
                
                for (let checkY = minY + 1; checkY < maxY; checkY++) {
                    if (getPieceAtPosition(x, checkY)) {
                        return false;
                    }
                }
                
                return true;
            }

            // Find the enemy general
            function findEnemyGeneral() {
                const enemyColor = currentPlayer === RED ? BLACK : RED;
                return document.querySelector(`.piece[data-type="general"][data-color="${enemyColor}"]`);
            }

            // Get possible moves for Advisor/Minister
            function getAdvisorMoves(x, y) {
                const color = currentPlayer;
                const moves = [];
                const directions = [
                    {dx: 1, dy: 1}, {dx: 1, dy: -1},
                    {dx: -1, dy: 1}, {dx: -1, dy: -1}
                ];
                
                directions.forEach(dir => {
                    const newX = x + dir.dx;
                    const newY = y + dir.dy;
                    
                    // Check if the move is within the palace and not occupied by own piece
                    if (isWithinPalace(newX, newY, color) && 
                        (getPieceAtPosition(newX, newY)?.dataset.color !== color || !getPieceAtPosition(newX, newY))) {
                        moves.push({x: newX, y: newY});
                    }
                });
                
                return moves;
            }

            // Get possible moves for Elephant/Minister
            function getElephantMoves(x, y) {
                const color = currentPlayer;
                const moves = [];
                const directions = [
                    {dx: 2, dy: 2}, {dx: 2, dy: -2},
                    {dx: -2, dy: 2}, {dx: -2, dy: -2}
                ];
                
                directions.forEach(dir => {
                    const newX = x + dir.dx;
                    const newY = y + dir.dy;
                    const midX = x + dir.dx / 2;
                    const midY = y + dir.dy / 2;
                    
                    // Check if the move is within bounds, not crossing river, and not blocked
                    if (isValidPosition(newX, newY) && 
                        !crossesRiver(newY, color) && 
                        !getPieceAtPosition(midX, midY) && 
                        (getPieceAtPosition(newX, newY)?.dataset.color !== color || !getPieceAtPosition(newX, newY))) {
                        moves.push({x: newX, y: newY});
                    }
                });
                
                return moves;
            }

            // Check if a position crosses the river
            function crossesRiver(y, color) {
                // Red pieces cannot go above the river (y < 5)
                if (color === RED) {
                    return y < 5;
                }
                // Black pieces cannot go below the river (y > 4)
                else {
                    return y > 4;
                }
            }

            // Get possible moves for Horse/Knight
            function getHorseMoves(x, y) {
                const color = currentPlayer;
                const moves = [];
                const directions = [
                    // Up-right, up-left, right-up, right-down, down-right, down-left, left-up, left-down
                    {dx: 1, dy: -2, blockX: 0, blockY: -1},
                    {dx: -1, dy: -2, blockX: 0, blockY: -1},
                    {dx: 2, dy: -1, blockX: 1, blockY: 0},
                    {dx: 2, dy: 1, blockX: 1, blockY: 0},
                    {dx: 1, dy: 2, blockX: 0, blockY: 1},
                    {dx: -1, dy: 2, blockX: 0, blockY: 1},
                    {dx: -2, dy: -1, blockX: -1, blockY: 0},
                    {dx: -2, dy: 1, blockX: -1, blockY: 0}
                ];
                
                directions.forEach(dir => {
                    const newX = x + dir.dx;
                    const newY = y + dir.dy;
                    const blockX = x + dir.blockX;
                    const blockY = y + dir.blockY;
                    
                    // Check if the move is within bounds, not blocked, and not occupied by own piece
                    if (isValidPosition(newX, newY) && 
                        !getPieceAtPosition(blockX, blockY) && 
                        (getPieceAtPosition(newX, newY)?.dataset.color !== color || !getPieceAtPosition(newX, newY))) {
                        moves.push({x: newX, y: newY});
                    }
                });
                
                return moves;
            }

            // Get possible moves for Chariot/Rook
            function getChariotMoves(x, y) {
                const color = currentPlayer;
                const moves = [];
                
                // Check in all four directions (up, right, down, left)
                const directions = [
                    {dx: 0, dy: -1}, // up
                    {dx: 1, dy: 0},  // right
                    {dx: 0, dy: 1},  // down
                    {dx: -1, dy: 0}  // left
                ];
                
                directions.forEach(dir => {
                    let newX = x + dir.dx;
                    let newY = y + dir.dy;
                    
                    // Keep moving in that direction until reaching a boundary or a piece
                    while (isValidPosition(newX, newY)) {
                        const pieceAtPosition = getPieceAtPosition(newX, newY);
                        
                        if (!pieceAtPosition) {
                            // Empty space, can move here
                            moves.push({x: newX, y: newY});
                        } else {
                            // Found a piece
                            if (pieceAtPosition.dataset.color !== color) {
                                // Enemy piece, can capture
                                moves.push({x: newX, y: newY});
                            }
                            // Stop looking in this direction
                            break;
                        }
                        
                        newX += dir.dx;
                        newY += dir.dy;
                    }
                });
                
                return moves;
            }

            // Get possible moves for Cannon
            function getCannonMoves(x, y) {
                const color = currentPlayer;
                const moves = [];
                
                // Check in all four directions (up, right, down, left)
                const directions = [
                    {dx: 0, dy: -1}, // up
                    {dx: 1, dy: 0},  // right
                    {dx: 0, dy: 1},  // down
                    {dx: -1, dy: 0}  // left
                ];
                
                directions.forEach(dir => {
                    let newX = x + dir.dx;
                    let newY = y + dir.dy;
                    let foundPlatform = false;
                    
                    // Keep moving in that direction
                    while (isValidPosition(newX, newY)) {
                        const pieceAtPosition = getPieceAtPosition(newX, newY);
                        
                        if (!pieceAtPosition) {
                            // Empty space
                            if (!foundPlatform) {
                                // Can move here if no platform found yet
                                moves.push({x: newX, y: newY});
                            }
                        } else {
                            // Found a piece
                            if (!foundPlatform) {
                                // First piece encountered becomes the platform
                                foundPlatform = true;
                            } else {
                                // Second piece encountered
                                if (pieceAtPosition.dataset.color !== color) {
                                    // Enemy piece, can capture
                                    moves.push({x: newX, y: newY});
                                }
                                // Stop looking in this direction
                                break;
                            }
                        }
                        
                        newX += dir.dx;
                        newY += dir.dy;
                    }
                });
                
                return moves;
            }

            // Get possible moves for Soldier/Pawn
            function getSoldierMoves(x, y) {
                const color = currentPlayer;
                const moves = [];
                
                if (color === RED) {
                    // Red soldier moves up
                    if (isValidPosition(x, y - 1)) {
                        if (!getPieceAtPosition(x, y - 1) || getPieceAtPosition(x, y - 1).dataset.color !== color) {
                            moves.push({x: x, y: y - 1});
                        }
                    }
                    
                    // If soldier has crossed the river, it can move horizontally
                    if (y <= 4) {
                        // Check left
                        if (isValidPosition(x - 1, y)) {
                            if (!getPieceAtPosition(x - 1, y) || getPieceAtPosition(x - 1, y).dataset.color !== color) {
                                moves.push({x: x - 1, y: y});
                            }
                        }
                        
                        // Check right
                        if (isValidPosition(x + 1, y)) {
                            if (!getPieceAtPosition(x + 1, y) || getPieceAtPosition(x + 1, y).dataset.color !== color) {
                                moves.push({x: x + 1, y: y});
                            }
                        }
                    }
                } else {
                    // Black soldier moves down
                    if (isValidPosition(x, y + 1)) {
                        if (!getPieceAtPosition(x, y + 1) || getPieceAtPosition(x, y + 1).dataset.color !== color) {
                            moves.push({x: x, y: y + 1});
                        }
                    }
                    
                    // If soldier has crossed the river, it can move horizontally
                    if (y >= 5) {
                        // Check left
                        if (isValidPosition(x - 1, y)) {
                            if (!getPieceAtPosition(x - 1, y) || getPieceAtPosition(x - 1, y).dataset.color !== color) {
                                moves.push({x: x - 1, y: y});
                            }
                        }
                        
                        // Check right
                        if (isValidPosition(x + 1, y)) {
                            if (!getPieceAtPosition(x + 1, y) || getPieceAtPosition(x + 1, y).dataset.color !== color) {
                                moves.push({x: x + 1, y: y});
                            }
                        }
                    }
                }
                
                return moves;
            }

            // Check if a position is valid (within board boundaries)
            function isValidPosition(x, y) {
                return x >= 0 && x < BOARD_WIDTH && y >= 0 && y < BOARD_HEIGHT;
            }

            // Get the piece at a specific position
            function getPieceAtPosition(x, y) {
                return document.querySelector(`.piece[data-x="${x}"][data-y="${y}"]`);
            }

            // Check if a move is possible
            function isPossibleMove(fromX, fromY, toX, toY) {
                const pieceElement = getPieceAtPosition(fromX, fromY);
                if (!pieceElement) return false;
                
                const pieceType = pieceElement.dataset.type;
                let possibleMoves = [];
                
                switch (pieceType) {
                    case 'general':
                        possibleMoves = getGeneralMoves(fromX, fromY);
                        break;
                    case 'advisor':
                        possibleMoves = getAdvisorMoves(fromX, fromY);
                        break;
                    case 'elephant':
                        possibleMoves = getElephantMoves(fromX, fromY);
                        break;
                    case 'horse':
                        possibleMoves = getHorseMoves(fromX, fromY);
                        break;
                    case 'chariot':
                        possibleMoves = getChariotMoves(fromX, fromY);
                        break;
                    case 'cannon':
                        possibleMoves = getCannonMoves(fromX, fromY);
                        break;
                    case 'soldier':
                        possibleMoves = getSoldierMoves(fromX, fromY);
                        break;
                }
                
                return possibleMoves.some(move => move.x === toX && move.y === toY);
            }

            // Move a piece
            function movePiece(pieceElement, toX, toY) {
                if (gameOver || aiThinking) return;
                
                const fromX = parseInt(pieceElement.dataset.x);
                const fromY = parseInt(pieceElement.dataset.y);
                
                // Check if there's a piece at the destination
                const targetPiece = getPieceAtPosition(toX, toY);
                
                // Save move for history
                const moveData = {
                    piece: {
                        type: pieceElement.dataset.type,
                        color: pieceElement.dataset.color,
                        fromX: fromX,
                        fromY: fromY,
                        toX: toX,
                        toY: toY
                    },
                    captured: targetPiece ? {
                        type: targetPiece.dataset.type,
                        color: targetPiece.dataset.color,
                        x: toX,
                        y: toY
                    } : null
                };
                
                moveHistory.push(moveData);
                
                // Remove target piece if it exists (capture)
                if (targetPiece) {
                    // Check if the captured piece is a general
                    if (targetPiece.dataset.type === 'general') {
                        gameOver = true;
                        updateGameInfo(`${currentPlayer.toUpperCase()} wins!`);
                    }
                    
                    targetPiece.remove();
                }
                
                // Update piece position
                pieceElement.dataset.x = toX;
                pieceElement.dataset.y = toY;
                updatePiecePosition(pieceElement);
                
                // Deselect the piece
                deselectPiece();
                
                // Check if the move puts the opponent's general in check
                const isCheck = isInCheck(currentPlayer === RED ? BLACK : RED);
                
                // Switch players
                currentPlayer = currentPlayer === RED ? BLACK : RED;
                
                // Check if the current player is in checkmate
                const isCheckmate = isInCheckmate();
                
                if (isCheckmate) {
                    gameOver = true;
                    updateGameInfo(`${(currentPlayer === RED ? BLACK : RED).toUpperCase()} wins by checkmate!`);
                } else if (isCheck) {
                    updateGameInfo(`${currentPlayer.toUpperCase()}'s turn (In Check!)`);
                } else {
                    updateGameInfo(`${currentPlayer.toUpperCase()}'s turn`);
                }
                
                // Add piece labels to board
                document.querySelectorAll('.piece').forEach(piece => {
                    const type = piece.dataset.type;
                    const color = piece.dataset.color;
                    
                    // Add small text label below the piece symbol for clarity
                    const labelElement = piece.querySelector('.piece-text small');
                    if (!labelElement) {
                        const small = document.createElement('small');
                        small.style.display = 'block';
                        small.style.fontSize = 'calc(var(--grid-size) * 0.15)';
                        small.style.marginTop = '2px';
                        small.textContent = color.charAt(0).toUpperCase();
                        piece.querySelector('.piece-text').appendChild(small);
                    }
                });
                
                // If it's Black's turn and AI is enabled, make AI move after a short delay
                if (currentPlayer === BLACK && aiEnabled && !gameOver) {
                    // Use a timeout to make it look like the AI is thinking
                    setTimeout(() => {
                        makeAIMove();
                    }, 500);
                }
            }

            // Check if a player's general is in check
            function isInCheck(playerColor) {
                const general = document.querySelector(`.piece[data-type="general"][data-color="${playerColor}"]`);
                if (!general) return false;
                
                const generalX = parseInt(general.dataset.x);
                const generalY = parseInt(general.dataset.y);
                
                // Get all enemy pieces
                const enemyPieces = document.querySelectorAll(`.piece[data-color="${playerColor === RED ? BLACK : RED}"]`);
                
                // Check if any enemy piece can capture the general
                for (const piece of enemyPieces) {
                    const pieceX = parseInt(piece.dataset.x);
                    const pieceY = parseInt(piece.dataset.y);
                    const pieceType = piece.dataset.type;
                    
                    // Temporarily change the current player to check moves
                    const savedCurrentPlayer = currentPlayer;
                    currentPlayer = playerColor === RED ? BLACK : RED;
                    
                    let possibleMoves = [];
                    switch (pieceType) {
                        case 'general':
                            possibleMoves = getGeneralMoves(pieceX, pieceY);
                            break;
                        case 'advisor':
                            possibleMoves = getAdvisorMoves(pieceX, pieceY);
                            break;
                        case 'elephant':
                            possibleMoves = getElephantMoves(pieceX, pieceY);
                            break;
                        case 'horse':
                            possibleMoves = getHorseMoves(pieceX, pieceY);
                            break;
                        case 'chariot':
                            possibleMoves = getChariotMoves(pieceX, pieceY);
                            break;
                        case 'cannon':
                            possibleMoves = getCannonMoves(pieceX, pieceY);
                            break;
                        case 'soldier':
                            possibleMoves = getSoldierMoves(pieceX, pieceY);
                            break;
                    }
                    
                    // Restore the current player
                    currentPlayer = savedCurrentPlayer;
                    
                    // Check if the general's position is in the possible moves
                    if (possibleMoves.some(move => move.x === generalX && move.y === generalY)) {
                        return true;
                    }
                }
                
                return false;
            }

            // Check if the current player is in checkmate
            function isInCheckmate() {
                // If not in check, cannot be in checkmate
                if (!isInCheck(currentPlayer)) return false;
                
                // Get all of the player's pieces
                const playerPieces = document.querySelectorAll(`.piece[data-color="${currentPlayer}"]`);
                
                // Check if any piece can make a move that gets out of check
                for (const piece of playerPieces) {
                    const pieceX = parseInt(piece.dataset.x);
                    const pieceY = parseInt(piece.dataset.y);
                    const pieceType = piece.dataset.type;
                    
                    let possibleMoves = [];
                    switch (pieceType) {
                        case 'general':
                            possibleMoves = getGeneralMoves(pieceX, pieceY);
                            break;
                        case 'advisor':
                            possibleMoves = getAdvisorMoves(pieceX, pieceY);
                            break;
                        case 'elephant':
                            possibleMoves = getElephantMoves(pieceX, pieceY);
                            break;
                        case 'horse':
                            possibleMoves = getHorseMoves(pieceX, pieceY);
                            break;
                        case 'chariot':
                            possibleMoves = getChariotMoves(pieceX, pieceY);
                            break;
                        case 'cannon':
                            possibleMoves = getCannonMoves(pieceX, pieceY);
                            break;
                        case 'soldier':
                            possibleMoves = getSoldierMoves(pieceX, pieceY);
                            break;
                    }
                    
                    // For each possible move, check if it gets out of check
                    for (const move of possibleMoves) {
                        if (moveEscapesCheck(piece, move.x, move.y)) {
                            return false; // Found a move that escapes check
                        }
                    }
                }
                
                // No moves found that escape check
                return true;
            }

            // Check if a move would get the player out of check
            function moveEscapesCheck(pieceElement, toX, toY) {
                const fromX = parseInt(pieceElement.dataset.x);
                const fromY = parseInt(pieceElement.dataset.y);
                const pieceColor = pieceElement.dataset.color;
                
                // Save original position
                const originalX = fromX;
                const originalY = fromY;
                
                // Check if there's a piece at the destination
                const targetPiece = getPieceAtPosition(toX, toY);
                let targetPieceData = null;
                
                if (targetPiece) {
                    targetPieceData = {
                        element: targetPiece,
                        x: parseInt(targetPiece.dataset.x),
                        y: parseInt(targetPiece.dataset.y),
                        type: targetPiece.dataset.type,
                        color: targetPiece.dataset.color
                    };
                    
                    // Temporarily remove the target piece
                    targetPiece.remove();
                }
                
                // Temporarily move the piece
                pieceElement.dataset.x = toX;
                pieceElement.dataset.y = toY;
                
                // Check if the king is still in check after the move
                const stillInCheck = isInCheck(pieceColor);
                
                // Restore original position
                pieceElement.dataset.x = originalX;
                pieceElement.dataset.y = originalY;
                
                // Restore target piece if it existed
                if (targetPieceData) {
                    const restoredPiece = createPieceElement({
                        type: targetPieceData.type,
                        color: targetPieceData.color,
                        x: targetPieceData.x,
                        y: targetPieceData.y
                    });
                }
                
                return !stillInCheck;
            }

            // Update game info text
            function updateGameInfo(text) {
                gameInfoElement.textContent = text;
            }

            // Undo last move
            function undoLastMove() {
                if (moveHistory.length === 0 || gameOver) return;
                
                const lastMove = moveHistory.pop();
                
                // Find the piece that was moved
                const pieceElement = getPieceAtPosition(lastMove.piece.toX, lastMove.piece.toY);
                if (pieceElement) {
                    // Move it back
                    pieceElement.dataset.x = lastMove.piece.fromX;
                    pieceElement.dataset.y = lastMove.piece.fromY;
                    updatePiecePosition(pieceElement);
                }
                
                // Restore captured piece if any
                if (lastMove.captured) {
                    createPieceElement({
                        type: lastMove.captured.type,
                        color: lastMove.captured.color,
                        x: lastMove.captured.x,
                        y: lastMove.captured.y
                    });
                }
                
                // Switch back to previous player
                currentPlayer = currentPlayer === RED ? BLACK : RED;
                
                // Update game info
                gameOver = false;
                updateGameInfo(`${currentPlayer.toUpperCase()}'s turn`);
            }

            // Event listeners
            newGameButton.addEventListener('click', initGame);
            undoMoveButton.addEventListener('click', undoLastMove);
            aiToggleButton.addEventListener('click', toggleAI);
            
            // Toggle AI on/off
            function toggleAI() {
                aiEnabled = !aiEnabled;
                aiToggleButton.textContent = `AI Opponent: ${aiEnabled ? 'ON' : 'OFF'}`;
                
                if (aiEnabled) {
                    aiToggleButton.classList.add('active');
                    // If it's Black's turn, make the AI move
                    if (currentPlayer === BLACK && !gameOver) {
                        makeAIMove();
                    }
                } else {
                    aiToggleButton.classList.remove('active');
                }
            }

            // Initialize the game
            initGame();
        });
    </script>
</body>
</html>